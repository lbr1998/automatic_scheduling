{"name":"My First Workflow - Leon Dri","description":null,"organizationId":809967,"isEnabled":false,"crontab":null,"timezone":"Europe/Berlin","blockData":[{"top":112,"left":-944,"uuid":"3316925c-6331-4ce7-889e-4d7e410da061","options":{},"pluginId":"startTrigger","blockType":"webhook","editorType":"JavascriptQuery","environment":"production","isMinimized":false,"resourceName":"webhook","incomingOnSuccessEdges":[]},{"top":48,"left":656,"uuid":"910114db-72a9-4373-9e86-c438bc393720","pluginId":"ProcessFiles","blockType":"code","dimensions":{"width":496,"height":552},"editorType":"PythonQuery","environment":"production","resourceName":"PythonQuery","responsePanelState":"open","incomingOnSuccessEdges":["385f8c74-ec68-4725-a9dd-b836cd6b71fd","49128a4d-1a6a-4665-8e75-00b5024cd0bf"]},{"top":48,"left":1264,"uuid":"a2650854-9b38-41f2-951e-8f01df580b7d","options":{"body":"{\n  \"image_base64\": ProcessFiles.data.image_base64,\n  \"results\": ProcessFiles.data.results,\n  \"failed\": ProcessFiles.data.failed\n}","status":"200"},"pluginId":"webhookReturn1","blockType":"webhookReturn","editorType":"JavascriptQuery","environment":"production","isMinimized":false,"resourceName":"JavascriptQuery","responsePanelState":"open","incomingOnSuccessEdges":["910114db-72a9-4373-9e86-c438bc393720"]},{"top":-144,"left":-352,"uuid":"e4945d76-214e-4e61-ab5b-2fdd58cffbed","pluginId":"query1","blockType":"default","editorType":"SqlQueryUnified","environment":"production","resourceName":"c76d34d0-a3bd-4f7d-a00f-9749addb23c1","responsePanelState":"open","incomingOnSuccessEdges":["3316925c-6331-4ce7-889e-4d7e410da061"]},{"top":480,"left":-352,"uuid":"90a2071c-3f0f-49e0-98af-4701b72db7c6","pluginId":"query2","blockType":"default","editorType":"SqlQueryUnified","environment":"production","resourceName":"c76d34d0-a3bd-4f7d-a00f-9749addb23c1","responsePanelState":"open","incomingOnSuccessEdges":["3316925c-6331-4ce7-889e-4d7e410da061"]},{"top":-144,"left":128,"uuid":"385f8c74-ec68-4725-a9dd-b836cd6b71fd","pluginId":"code1","blockType":"code","editorType":"PythonQuery","environment":"production","resourceName":"PythonQuery","responsePanelState":"open","incomingOnSuccessEdges":["e4945d76-214e-4e61-ab5b-2fdd58cffbed"]},{"top":480,"left":112,"uuid":"49128a4d-1a6a-4665-8e75-00b5024cd0bf","pluginId":"code2","blockType":"code","editorType":"PythonQuery","environment":"production","resourceName":"PythonQuery","responsePanelState":"open","incomingOnSuccessEdges":["90a2071c-3f0f-49e0-98af-4701b72db7c6"]}],"templateData":"[\"~#iR\",[\"^ \",\"n\",\"appTemplate\",\"v\",[\"^ \",\"isFetching\",false,\"plugins\",[\"~#iOM\",[\"startTrigger\",[\"^0\",[\"^ \",\"n\",\"pluginTemplate\",\"v\",[\"^ \",\"id\",\"startTrigger\",\"uuid\",null,\"type\",\"datasource\",\"subtype\",\"JavascriptQuery\",\"namespace\",null,\"resourceName\",\"JavascriptQuery\",\"resourceDisplayName\",null,\"template\",[\"^3\",[\"queryRefreshTime\",\"\",\"allowedGroupIds\",[\"~#iL\",[]],\"streamResponse\",false,\"lastReceivedFromResourceAt\",null,\"queryDisabledMessage\",\"\",\"servedFromCache\",false,\"offlineUserQueryInputs\",\"\",\"successMessage\",\"\",\"queryDisabled\",\"\",\"playgroundQuerySaveId\",\"latest\",\"workflowParams\",null,\"resourceNameOverride\",\"\",\"runWhenModelUpdates\",false,\"workflowRunId\",null,\"showFailureToaster\",true,\"query\",\"return {\\n  \\\"date\\\": \\\"2024-08-01\\\"\\n}\",\"playgroundQueryUuid\",\"\",\"playgroundQueryId\",null,\"error\",null,\"workflowRunBodyType\",\"raw\",\"privateParams\",[\"^;\",[]],\"workflowBlockUuid\",null,\"queryRunOnSelectorUpdate\",false,\"runWhenPageLoadsDelay\",\"\",\"data\",null,\"importedQueryInputs\",[\"^3\",[]],\"_additionalScope\",[\"^;\",[]],\"isImported\",false,\"showSuccessToaster\",true,\"cacheKeyTtl\",\"\",\"requestSentTimestamp\",null,\"metadata\",null,\"workflowActionType\",null,\"queryRunTime\",null,\"changesetObject\",\"\",\"errorTransformer\",\"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\"finished\",null,\"confirmationMessage\",null,\"isFetching\",false,\"changeset\",\"\",\"rawData\",null,\"queryTriggerDelay\",\"0\",\"resourceTypeOverride\",null,\"watchedParams\",[\"^;\",[]],\"enableErrorTransformer\",false,\"showLatestVersionUpdatedWarning\",false,\"timestamp\",0,\"evalType\",\"script\",\"importedQueryDefaults\",[\"^3\",[]],\"enableTransformer\",false,\"showUpdateSetValueDynamicallyToggle\",true,\"overrideOrgCacheForUserCache\",false,\"runWhenPageLoads\",false,\"transformer\",\"// Query results are available as the `data` variable\\nreturn data\",\"events\",[\"^;\",[]],\"queryTimeout\",\"10000\",\"workflowId\",null,\"requireConfirmation\",false,\"queryFailureConditions\",\"\",\"changesetIsObject\",false,\"enableCaching\",false,\"allowedGroups\",[\"^;\",[]],\"offlineQueryType\",\"None\",\"queryThrottleTime\",\"750\",\"updateSetValueDynamically\",false,\"notificationDuration\",\"\"]],\"style\",null,\"position2\",null,\"mobilePosition2\",null,\"mobileAppPosition\",null,\"tabIndex\",null,\"container\",\"\",\"createdAt\",\"~m1719849111327\",\"updatedAt\",\"~m1720886035781\",\"folder\",\"\",\"screen\",null]]],\"ProcessFiles\",[\"^0\",[\"^ \",\"n\",\"pluginTemplate\",\"v\",[\"^ \",\"id\",\"ProcessFiles\",\"^4\",null,\"^5\",\"datasource\",\"^6\",\"PythonQuery\",\"^7\",null,\"^8\",\"PythonQuery\",\"^9\",null,\"^:\",[\"^3\",[\"queryRefreshTime\",\"\",\"allowedGroupIds\",[\"^;\",[]],\"streamResponse\",false,\"lastReceivedFromResourceAt\",null,\"queryDisabledMessage\",\"\",\"servedFromCache\",false,\"offlineUserQueryInputs\",\"\",\"successMessage\",\"\",\"queryDisabled\",\"\",\"playgroundQuerySaveId\",\"latest\",\"workflowParams\",null,\"resourceNameOverride\",\"\",\"runWhenModelUpdates\",false,\"workflowRunId\",null,\"showFailureToaster\",true,\"query\",\"import googlemaps\\nfrom datetime import datetime, timedelta\\nfrom typing import List, Dict, Tuple, Union\\n\\nimport matplotlib.pyplot as plt\\nimport matplotlib.dates as mdates\\nfrom datetime import datetime\\nimport base64\\nimport io\\n\\nclass Employee:\\n    \\\"\\\"\\\"\\n    Represents an employee with an ID, maximum working hours, maximum task priority they can handle, \\n    available times, and assigned tasks.\\n\\n    Attributes:\\n        employee_id (str): The ID of the employee.\\n        max_hours (int): The maximum number of working hours the employee can handle.\\n        max_priority (int): The maximum priority level of tasks the employee can handle.\\n        available_times (List[Tuple[datetime, datetime]]): The available time slots for the employee.\\n        assigned_tasks (List): The list of tasks assigned to the employee.\\n    \\\"\\\"\\\"\\n    def __init__(self, employee_id: str, max_hours: float, max_priority: int, available_times: List[Tuple[datetime, datetime]]):\\n        self.employee_id = employee_id\\n        self.max_hours = max_hours\\n        self.max_priority = max_priority\\n        self.available_times = available_times\\n        self.assigned_tasks = []\\n\\n\\nclass Task:\\n    def __init__(self, user_id: str, start_location: str, end_location: str, priority: int, \\n                 departure_time: Union[datetime, None] = None, arrival_time: Union[datetime, None] = None):\\n        self.user_id = user_id\\n        self.start_location = start_location\\n        self.end_location = end_location\\n        self.priority = priority\\n        self.departure_time = departure_time\\n        self.arrival_time = arrival_time\\n        self.duration = None  # Initialize duration\\n\\n        if self.departure_time is None and self.arrival_time is None:\\n            raise ValueError(\\\"Either departure_time or arrival_time must be provided.\\\")\\n        \\n        # Calculate missing time if needed\\n        if self.departure_time is None or self.arrival_time is None:\\n            _, self.duration, self.departure_time, self.arrival_time = calculate_travel_details(self.start_location, self.end_location, departure_time=self.departure_time, arrival_time=self.arrival_time)\\n\\n# Please ensure you have set your API key\\nAPI_KEY = 'AIzaSyAYIUeYv11ZkUdtepsO_NrHmVD57WYsw6w'  # Replace with your actual API key\\ngmaps = googlemaps.Client(key=API_KEY)\\n\\ndef calculate_travel_details(start_location: str, end_location: str, departure_time: Union[datetime, None] = None, arrival_time: Union[datetime, None] = None, mode: str = \\\"transit\\\") -> Tuple[float, float, datetime, datetime]:\\n    \\\"\\\"\\\"\\n    Calculate travel details between two locations using Google Maps API.\\n\\n    Args:\\n        start_location (str): The starting location.\\n        end_location (str): The destination location.\\n        departure_time (Union[datetime, None], optional): The departure time. Defaults to None.\\n        arrival_time (Union[datetime, None], optional): The arrival time. Defaults to None.\\n        mode (str, optional): The mode of transport (e.g., \\\"transit\\\", \\\"driving\\\"). Defaults to \\\"transit\\\".\\n\\n    Returns:\\n        Tuple[float, float, datetime, datetime]: The distance in kilometers, duration in minutes, departure time, and arrival time.\\n    \\\"\\\"\\\"\\n    directions_result = gmaps.directions(start_location, end_location, mode=mode)\\n\\n    if directions_result:\\n        leg = directions_result[0]['legs'][0]\\n        distance = leg['distance']['value'] / 1000  # Distance in kilometers\\n        duration = leg['duration']['value'] / 60  # Duration in minutes\\n        \\n        if departure_time:\\n            arrival_time = departure_time + timedelta(minutes=duration)\\n            return distance, duration, departure_time, arrival_time\\n        elif arrival_time:\\n            departure_time = arrival_time - timedelta(minutes=duration)\\n            return distance, duration, departure_time, arrival_time\\n        else:\\n            return distance, duration, None, None\\n    \\n    return float('inf'), float('inf'), None, None\\n\\n\\nclass TaskScheduler:\\n    def __init__(self, tasks: List[Task], employees: List[Employee]):\\n        \\\"\\\"\\\"\\n        Initialize the task scheduler with a list of tasks and a list of employees.\\n\\n        Args:\\n            tasks (List[Task]): List of tasks.\\n            employees (List[Employee]): List of employees.\\n        \\\"\\\"\\\"\\n        self.tasks = tasks\\n        self.employees = employees\\n        self.assignments = []  # Record of task assignments\\n        self.failed_assignments = []  # Record of tasks that couldn't be assigned\\n\\n    def can_assign(self, task: Task, employee: Employee) -> bool:\\n        \\\"\\\"\\\"\\n        Check if a task can be assigned to an employee.\\n\\n        Args:\\n            task (Task): Task instance.\\n            employee (Employee): Employee instance.\\n\\n        Returns:\\n            bool: True if the task can be assigned, False otherwise.\\n        \\\"\\\"\\\"\\n        # Check if the employee already has 5 tasks assigned for the day\\n        if len(employee.assigned_tasks) >= 4:\\n            return False\\n        \\n        # Check if the task priority is higher than the employee's max priority\\n        if task.priority < employee.max_priority:\\n            return False\\n\\n        # Check if the task fits into any of the employee's available time slots\\n        for available_start, available_end in employee.available_times:\\n            if available_start <= task.departure_time <= available_end and available_start <= task.arrival_time <= available_end:\\n                return True\\n            \\n        # for available_start, available_end in employee.available_times:\\n        #     if available_start <= task.departure_time <= available_end and available_start <= task.arrival_time <= available_end:\\n        #         # Check if there is enough time for travel from the closest assigned task to the current task\\n        #         if employee.assigned_tasks:\\n        #             closest_task_1 = min(employee.assigned_tasks, key=lambda t: abs((t.arrival_time - task.departure_time).total_seconds()))\\n        #             _, travel_time_1, _, _ = calculate_travel_details(closest_task_1.end_location, task.start_location)\\n        #             closest_task_2 = min(employee.assigned_tasks, key=lambda t: abs((task.arrival_time - t.departure_time).total_seconds()))\\n        #             _, travel_time_2, _, _ = calculate_travel_details(task.end_location, closest_task_2.start_location)\\n        #             if (closest_task_1.arrival_time + timedelta(minutes=travel_time_1) > task.departure_time or\\n        #                 task.arrival_time + timedelta(minutes=travel_time_2) > closest_task_2.departure_time):\\n        #                 return False\\n        #         return True\\n        \\n        return False\\n\\n    def assign_task(self, task: Task, employee: Employee, tasks_for_date: List[Task]):\\n        \\\"\\\"\\\"\\n        Assign a task to an employee and update their available times and assignments.\\n\\n        Args:\\n            task (Task): Task instance.\\n            employee (Employee): Employee instance.\\n            tasks_for_date (List[Task]): List of tasks for the specific date.\\n        \\\"\\\"\\\"\\n        total_task_duration = task.duration\\n\\n        # If the employee already has assigned tasks, calculate travel time from the last task\\n        if employee.assigned_tasks:\\n            previous_task = employee.assigned_tasks[-1]\\n            _, travel_time, _, _ = calculate_travel_details(previous_task.end_location, task.start_location)\\n            total_task_duration += travel_time\\n        \\n        # Deduct the total task duration from the employee's available hours\\n        employee.max_hours -= total_task_duration / 60\\n        self.assignments.append((task, employee.employee_id))\\n        employee.assigned_tasks.append(task)\\n\\n        # Update the employee's available times\\n        new_available_times = []\\n        for available_start, available_end in employee.available_times:\\n            if available_start <= task.departure_time and task.arrival_time <= available_end:\\n                if available_start < task.departure_time:\\n                    new_available_times.append((available_start, task.departure_time))\\n                if task.arrival_time < available_end:\\n                    new_available_times.append((task.arrival_time, available_end))\\n            else:\\n                new_available_times.append((available_start, available_end))\\n\\n        employee.available_times = new_available_times\\n        remaining_tasks = [t for t in tasks_for_date if t not in self.assignments and t not in self.failed_assignments]\\n\\n        # Attempt to assign the closest subsequent task to the employee\\n        self.assign_closed_task(task, employee, remaining_tasks)\\n\\n    def assign_tasks_for_date(self, date: datetime):\\n        \\\"\\\"\\\"\\n        Assign tasks for a specific date.\\n\\n        Args:\\n            date (datetime): The date for which tasks are to be assigned.\\n        \\\"\\\"\\\"\\n        # Filter tasks for the specific date\\n        tasks_for_date = [task for task in self.tasks if (task.departure_time and task.departure_time.date() == date.date())]\\n\\n        employees_for_date = [employee for employee in self.employees if (av_start.date() == date.date() for av_start, _ in employee.available_times)]\\n\\n        remaining_tasks = self.assign_remaining_tasks(tasks_for_date, employees_for_date, self.can_assign, self.assign_task)\\n\\n        # Attempt to reassign remaining tasks until no more progress can be made\\n        while remaining_tasks:\\n            new_remaining_tasks = self.assign_remaining_tasks(remaining_tasks, employees_for_date, self.can_assign, self.assign_task)\\n            if len(new_remaining_tasks) == len(remaining_tasks):\\n                break\\n            remaining_tasks = new_remaining_tasks\\n\\n    def assign_closed_task(self, task: Task, employee: Employee, tasks_for_date: List[Task]):\\n        \\\"\\\"\\\"\\n        Assign the closest subsequent task to the employee if possible.\\n\\n        Args:\\n            task (Task): Task instance.\\n            employee (Employee): Employee instance.\\n            tasks_for_date (List[Task]): List of tasks for the specific date.\\n        \\\"\\\"\\\"\\n        closed_task = None\\n        best_travel_time = float('inf')\\n        \\n        tasks_p = [t for t in tasks_for_date if t.priority == task.priority]\\n        # Find the closest task that fits into the employee's schedule\\n        for candidate_task in tasks_p:\\n            if candidate_task not in employee.assigned_tasks and candidate_task not in self.failed_assignments:\\n                candidate_start_time = candidate_task.departure_time\\n                \\n                if candidate_start_time:\\n                    _, travel_time, _, _ = calculate_travel_details(task.end_location, candidate_task.start_location)\\n                    interval_time = (candidate_start_time - task.arrival_time).total_seconds() / 60\\n\\n                    if 0 < interval_time - travel_time <= 60 and travel_time < best_travel_time:\\n                        best_travel_time = travel_time\\n                        closed_task = candidate_task\\n        \\n        # If a suitable task is found, assign it to the employee\\n        if closed_task:\\n            if self.can_assign(closed_task, employee):\\n                self.assign_task(closed_task, employee, tasks_for_date)\\n\\n    def assign_remaining_tasks(self, tasks_for_date: List[Task], employees: List[Employee], can_assign, assign_task):\\n        \\\"\\\"\\\"\\n        Assign remaining tasks to employees, attempting to balance the workload.\\n\\n        Args:\\n            tasks_for_date (List[Task]): List of tasks for the specific date.\\n            employees (List[Employee]): List of employees.\\n            can_assign (function): Function to check if a task can be assigned.\\n            assign_task (function): Function to assign a task.\\n\\n        Returns:\\n            List[Task]: List of tasks that could not be assigned.\\n        \\\"\\\"\\\"\\n        # Sort tasks by priority\\n        tasks_for_date.sort(key=lambda x: x.priority)\\n\\n        # Sort employees by the number of tasks they have assigned\\n        employees.sort(key=lambda e: len(e.assigned_tasks))\\n\\n        # Group tasks by user\\n        tasks_by_user = {}\\n        for task in tasks_for_date:\\n            if task.user_id not in tasks_by_user:\\n                tasks_by_user[task.user_id] = []\\n            tasks_by_user[task.user_id].append(task)\\n\\n        new_tasks_for_date = []\\n        rollback_state = {}  # Dictionary to store the state of each employee before attempting to assign tasks\\n\\n        for user_id, user_tasks in tasks_by_user.items():\\n            user_tasks.sort(key=lambda x: x.priority)\\n            assigned = False\\n\\n            # Save the current state of each employee\\n            rollback_state.clear()\\n            for employee in employees:\\n                rollback_state[employee] = (employee.available_times[:], employee.max_hours, employee.assigned_tasks[:])\\n\\n            # Try to assign tasks to employees\\n            for task in user_tasks:\\n                assigned_to_employee = False\\n                for employee in employees:\\n                    if can_assign(task, employee):\\n                        assign_task(task, employee, tasks_for_date)\\n                        assigned_to_employee = True\\n                        assigned = True\\n                        break\\n                if not assigned_to_employee:\\n                    # new_tasks_for_date.append(task)\\n                    self.failed_assignments.extend(user_tasks)\\n\\n            # Rollback if not all tasks for this user_id were assigned\\n            if not assigned:\\n                self.failed_assignments.extend(user_tasks)\\n\\n                # Rollback each employee's state\\n                for employee, state in rollback_state.items():\\n                    employee.available_times = state[0]\\n                    employee.max_hours = state[1]\\n                    employee.assigned_tasks = state[2]\\n\\n        return new_tasks_for_date\\n\\ndef visualize_schedule(scheduler: TaskScheduler, schedule_date: datetime):\\n    \\\"\\\"\\\"\\n    Visualize the task schedule for all employees on a given date.\\n\\n    Args:\\n        scheduler (TaskScheduler): The task scheduler containing assignments.\\n        schedule_date (datetime): The date for which the schedule should be visualized.\\n    \\\"\\\"\\\"\\n    fig, ax = plt.subplots(figsize=(15, 10))\\n    \\n    priority_colors = {\\n        1: 'tab:blue',\\n        2: 'tab:orange',\\n        3: 'tab:green',\\n        4: 'tab:red',\\n        5: 'tab:purple',\\n        6: 'tab:brown',\\n    }\\n    \\n    # Ensure all employees are shown on the y-axis\\n    employees_for_date = [employee for employee in employees if any(av_start.date() == schedule_date.date() for av_start, _ in employee.available_times)]\\n    employee_ids = [employee.employee_id for employee in employees_for_date]\\n    employee_index = {employee_id: idx for idx, employee_id in enumerate(employee_ids)}\\n    \\n    for assignment in scheduler.assignments:\\n        task, employee_id = assignment\\n        if employee_id:\\n            _, _, departure_time, arrival_time = calculate_travel_details(task.start_location, task.end_location, task.departure_time or task.arrival_time)\\n            if departure_time.date() == schedule_date.date():\\n                start = mdates.date2num(departure_time)\\n                end = mdates.date2num(arrival_time)\\n                priority_color = priority_colors.get(task.priority, 'gray')\\n                \\n                ax.barh(employee_index[employee_id], end - start, left=start, color=priority_color, edgecolor='black', align='center', alpha=0.7)\\n                ax.text(start, employee_index[employee_id], f\\\"{task.user_id}\\\", va='center', ha='left', color='black')\\n    \\n    # Draw horizontal lines for each employee\\n    for idx in range(len(employee_ids)):\\n        ax.axhline(y=idx, color='gray', linestyle='--', linewidth=0.5)\\n    \\n    # Set y-axis labels to employee IDs\\n    ax.set_yticks(range(len(employee_ids)))\\n    ax.set_yticklabels(employee_ids)\\n    \\n    # Set x-axis range from 7 AM to 7 PM\\n    start_of_day = datetime(schedule_date.year, schedule_date.month, schedule_date.day, 7, 0)\\n    end_of_day = datetime(schedule_date.year, schedule_date.month, schedule_date.day, 19, 0)\\n    ax.set_xlim(mdates.date2num(start_of_day), mdates.date2num(end_of_day))\\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\\n    ax.xaxis.set_major_locator(mdates.HourLocator(interval=1))\\n    \\n    plt.xticks(rotation=45)\\n    ax.set_xlabel('Time')\\n    ax.set_ylabel('Employees')\\n    ax.set_title('Task Schedule')\\n    \\n    legend_handles = []\\n    for priority, color in priority_colors.items():\\n        legend_handles.append(plt.Rectangle((0, 0), 1, 1, color=color, label=f'Priority {priority}'))\\n    ax.legend(handles=legend_handles, loc='upper left', bbox_to_anchor=(1, 1))\\n\\n    plt.tight_layout()\\n    \\n    # Save the plot to a BytesIO object\\n    img_buf = io.BytesIO()\\n    plt.savefig(img_buf, format='jpg', pad_inches=0.1, dpi=200)\\n    plt.close(fig)\\n    img_buf.seek(0)\\n\\n    # Encode the image to base64\\n    img_base64 = base64.b64encode(img_buf.read()).decode('utf-8')\\n    \\n    return img_base64\\n\\ntasks_data = code1.data\\ntasks = []\\nemployees_data = code2.data\\nemployees = []\\n\\nfor t in tasks_data:\\n    if t['start_time']:\\n        task = Task(t['user_id'], t['start_location'], t['end_location'], t['priority'], datetime.strptime(t['start_time'], \\\"%Y-%m-%dT%H:%M:%S\\\"), t['end_time'])\\n        tasks.append(task)\\n    else:\\n        task = Task(t['user_id'], t['start_location'], t['end_location'], t['priority'], t['start_time'], datetime.strptime(t['end_time'], \\\"%Y-%m-%dT%H:%M:%S\\\"))\\n        tasks.append(task)\\n\\nfor e in employees_data:\\n    available_time = [(datetime.strptime(e['start_time'], \\\"%Y-%m-%dT%H:%M:%S\\\"), datetime.strptime(e['end_time'], \\\"%Y-%m-%dT%H:%M:%S\\\"))]\\n    employee = Employee(e['employee_name'], e['max_hours'], e['max_priority'], available_time)\\n    employees.append(employee)\\n\\nscheduler = TaskScheduler(tasks, employees)\\nschedule_date = datetime.strptime(startTrigger.data.date, \\\"%Y-%m-%d\\\") # Set the date for task assignment\\nscheduler.assign_tasks_for_date(schedule_date)\\n\\nimg_base64 = visualize_schedule(scheduler, schedule_date)\\n\\nassignment = []\\nfor employee in employees:\\n    for task in employee.assigned_tasks:\\n      assignment.append({'emploee': employee.employee_id,\\n      'user': task.user_id,\\n      'priority': task.priority,\\n      'departure_time': task.departure_time,\\n      'arrival_time': task.arrival_time,\\n      'duration': task.duration})\\nassignment = [t for t in assignment if t['user'] is not None]\\n\\nfailed = []\\nfor task in scheduler.failed_assignments:\\n  failed.append({\\n      'user': task.user_id,\\n      'priority': task.priority,\\n      'departure_time': task.departure_time,\\n      'arrival_time': task.arrival_time,\\n      'duration': task.duration})\\n\\nunique_failed = list({tuple(d.items()) for d in failed})\\nfailed = [dict(t) for t in unique_failed]\\n\\nreturn {\\n        \\\"image_base64\\\": img_base64,\\n        \\\"results\\\": assignment,\\n        \\\"failed\\\": failed\\n    }\\n\",\"playgroundQueryUuid\",\"\",\"playgroundQueryId\",null,\"error\",null,\"workflowRunBodyType\",\"raw\",\"privateParams\",[\"^;\",[]],\"workflowBlockUuid\",null,\"queryRunOnSelectorUpdate\",false,\"runWhenPageLoadsDelay\",\"\",\"data\",null,\"importedQueryInputs\",[\"^3\",[]],\"isImported\",false,\"showSuccessToaster\",true,\"cacheKeyTtl\",\"\",\"requestSentTimestamp\",null,\"metadata\",null,\"workflowActionType\",null,\"queryRunTime\",null,\"changesetObject\",\"\",\"errorTransformer\",\"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\"finished\",null,\"confirmationMessage\",null,\"isFetching\",false,\"changeset\",\"\",\"rawData\",null,\"queryTriggerDelay\",\"0\",\"resourceTypeOverride\",null,\"watchedParams\",[\"^;\",[]],\"enableErrorTransformer\",false,\"showLatestVersionUpdatedWarning\",false,\"timestamp\",0,\"evalType\",\"script\",\"importedQueryDefaults\",[\"^3\",[]],\"enableTransformer\",false,\"showUpdateSetValueDynamicallyToggle\",true,\"overrideOrgCacheForUserCache\",false,\"runWhenPageLoads\",false,\"transformer\",\"// Query results are available as the `data` variable\\nreturn data\",\"events\",[\"^;\",[]],\"queryTimeout\",\"10000\",\"workflowId\",null,\"requireConfirmation\",false,\"queryFailureConditions\",\"\",\"changesetIsObject\",false,\"enableCaching\",false,\"allowedGroups\",[\"^;\",[]],\"offlineQueryType\",\"None\",\"queryThrottleTime\",\"750\",\"updateSetValueDynamically\",false,\"notificationDuration\",\"\"]],\"^<\",null,\"^=\",null,\"^>\",null,\"^?\",null,\"^@\",null,\"^A\",\"\",\"^B\",\"~m1719849111327\",\"^C\",\"~m1720886070123\",\"^D\",\"\",\"^E\",null]]],\"webhookReturn1\",[\"^0\",[\"^ \",\"n\",\"pluginTemplate\",\"v\",[\"^ \",\"id\",\"webhookReturn1\",\"^4\",null,\"^5\",\"datasource\",\"^6\",\"JavascriptQuery\",\"^7\",null,\"^8\",\"JavascriptQuery\",\"^9\",null,\"^:\",[\"^3\",[\"queryRefreshTime\",\"\",\"allowedGroupIds\",[\"^;\",[]],\"streamResponse\",false,\"lastReceivedFromResourceAt\",null,\"queryDisabledMessage\",\"\",\"servedFromCache\",false,\"offlineUserQueryInputs\",\"\",\"successMessage\",\"\",\"queryDisabled\",\"\",\"playgroundQuerySaveId\",\"latest\",\"workflowParams\",null,\"resourceNameOverride\",\"\",\"runWhenModelUpdates\",false,\"workflowRunId\",null,\"showFailureToaster\",true,\"query\",\"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  \\\"image_base64\\\": ProcessFiles.data.image_base64,\\n  \\\"results\\\": ProcessFiles.data.results,\\n  \\\"failed\\\": ProcessFiles.data.failed\\n}\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of webhookReturn1'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\"playgroundQueryUuid\",\"\",\"playgroundQueryId\",null,\"error\",null,\"workflowRunBodyType\",\"raw\",\"privateParams\",[\"^;\",[]],\"workflowBlockUuid\",null,\"queryRunOnSelectorUpdate\",false,\"runWhenPageLoadsDelay\",\"\",\"data\",null,\"importedQueryInputs\",[\"^3\",[]],\"_additionalScope\",[\"^;\",[]],\"isImported\",false,\"showSuccessToaster\",true,\"cacheKeyTtl\",\"\",\"requestSentTimestamp\",null,\"metadata\",null,\"workflowActionType\",null,\"editorMode\",\"sql\",\"queryRunTime\",null,\"changesetObject\",\"\",\"errorTransformer\",\"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\"finished\",null,\"confirmationMessage\",null,\"isFetching\",false,\"changeset\",\"\",\"rawData\",null,\"queryTriggerDelay\",\"0\",\"resourceTypeOverride\",null,\"watchedParams\",[\"^;\",[]],\"enableErrorTransformer\",false,\"showLatestVersionUpdatedWarning\",false,\"timestamp\",0,\"evalType\",\"script\",\"importedQueryDefaults\",[\"^3\",[]],\"enableTransformer\",false,\"showUpdateSetValueDynamicallyToggle\",true,\"overrideOrgCacheForUserCache\",false,\"runWhenPageLoads\",false,\"transformer\",\"// Query results are available as the `data` variable\\nreturn data\",\"events\",[\"^;\",[]],\"queryTimeout\",\"10000\",\"workflowId\",null,\"requireConfirmation\",false,\"queryFailureConditions\",\"\",\"changesetIsObject\",false,\"enableCaching\",false,\"allowedGroups\",[\"^;\",[]],\"offlineQueryType\",\"None\",\"queryThrottleTime\",\"750\",\"updateSetValueDynamically\",false,\"notificationDuration\",\"\"]],\"^<\",null,\"^=\",null,\"^>\",null,\"^?\",null,\"^@\",null,\"^A\",\"\",\"^B\",\"~m1719849378783\",\"^C\",\"~m1720875422156\",\"^D\",\"\",\"^E\",null]]],\"query1\",[\"^0\",[\"^ \",\"n\",\"pluginTemplate\",\"v\",[\"^ \",\"id\",\"query1\",\"^4\",null,\"^5\",\"datasource\",\"^6\",\"SqlQueryUnified\",\"^7\",null,\"^8\",\"c76d34d0-a3bd-4f7d-a00f-9749addb23c1\",\"^9\",null,\"^:\",[\"^3\",[\"queryRefreshTime\",\"\",\"allowedGroupIds\",[\"^;\",[]],\"streamResponse\",false,\"records\",\"\",\"lastReceivedFromResourceAt\",null,\"databasePasswordOverride\",\"\",\"queryDisabledMessage\",\"\",\"servedFromCache\",false,\"offlineUserQueryInputs\",\"\",\"successMessage\",\"\",\"queryDisabled\",\"\",\"playgroundQuerySaveId\",\"latest\",\"workflowParams\",null,\"resourceNameOverride\",\"\",\"runWhenModelUpdates\",false,\"workflowRunId\",null,\"showFailureToaster\",true,\"query\",\"select * from orders\",\"playgroundQueryUuid\",\"\",\"playgroundQueryId\",null,\"error\",null,\"workflowRunBodyType\",\"raw\",\"privateParams\",[\"^;\",[]],\"workflowBlockUuid\",null,\"queryRunOnSelectorUpdate\",false,\"runWhenPageLoadsDelay\",\"\",\"warningCodes\",[\"^;\",[]],\"data\",null,\"recordId\",\"\",\"importedQueryInputs\",[\"^3\",[]],\"_additionalScope\",[\"^;\",[]],\"isImported\",false,\"showSuccessToaster\",true,\"dataArray\",[\"^;\",[]],\"cacheKeyTtl\",\"\",\"filterBy\",\"\",\"requestSentTimestamp\",null,\"databaseHostOverride\",\"\",\"metadata\",null,\"workflowActionType\",null,\"editorMode\",\"sql\",\"queryRunTime\",null,\"actionType\",\"\",\"changesetObject\",\"\",\"shouldUseLegacySql\",false,\"errorTransformer\",\"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\"finished\",null,\"databaseNameOverride\",\"\",\"confirmationMessage\",null,\"isFetching\",false,\"changeset\",\"\",\"rawData\",null,\"queryTriggerDelay\",\"0\",\"resourceTypeOverride\",null,\"watchedParams\",[\"^;\",[]],\"enableErrorTransformer\",false,\"databaseWarehouseOverride\",\"\",\"enableBulkUpdates\",false,\"showLatestVersionUpdatedWarning\",false,\"timestamp\",0,\"evalType\",\"script\",\"importedQueryDefaults\",[\"^3\",[]],\"enableTransformer\",false,\"showUpdateSetValueDynamicallyToggle\",true,\"overrideOrgCacheForUserCache\",false,\"bulkUpdatePrimaryKey\",\"\",\"runWhenPageLoads\",false,\"transformer\",\"// Query results are available as the `data` variable\\nreturn data\",\"events\",[\"^;\",[]],\"tableName\",\"\",\"queryTimeout\",\"10000\",\"workflowId\",null,\"requireConfirmation\",false,\"queryFailureConditions\",\"\",\"changesetIsObject\",false,\"enableCaching\",false,\"allowedGroups\",[\"^;\",[]],\"databaseUsernameOverride\",\"\",\"databaseRoleOverride\",\"\",\"shouldEnableBatchQuerying\",false,\"doNotThrowOnNoOp\",false,\"offlineQueryType\",\"None\",\"queryThrottleTime\",\"750\",\"updateSetValueDynamically\",false,\"notificationDuration\",\"\"]],\"^<\",null,\"^=\",null,\"^>\",null,\"^?\",null,\"^@\",null,\"^A\",\"\",\"^B\",\"~m1720863376186\",\"^C\",\"~m1720863390397\",\"^D\",\"\",\"^E\",null]]],\"query2\",[\"^0\",[\"^ \",\"n\",\"pluginTemplate\",\"v\",[\"^ \",\"id\",\"query2\",\"^4\",null,\"^5\",\"datasource\",\"^6\",\"SqlQueryUnified\",\"^7\",null,\"^8\",\"c76d34d0-a3bd-4f7d-a00f-9749addb23c1\",\"^9\",null,\"^:\",[\"^3\",[\"queryRefreshTime\",\"\",\"allowedGroupIds\",[\"^;\",[]],\"streamResponse\",false,\"records\",\"\",\"lastReceivedFromResourceAt\",null,\"databasePasswordOverride\",\"\",\"queryDisabledMessage\",\"\",\"servedFromCache\",false,\"offlineUserQueryInputs\",\"\",\"successMessage\",\"\",\"queryDisabled\",\"\",\"playgroundQuerySaveId\",\"latest\",\"workflowParams\",null,\"resourceNameOverride\",\"\",\"runWhenModelUpdates\",false,\"workflowRunId\",null,\"showFailureToaster\",true,\"query\",\"select * from employees \",\"playgroundQueryUuid\",\"\",\"playgroundQueryId\",null,\"error\",null,\"workflowRunBodyType\",\"raw\",\"privateParams\",[\"^;\",[]],\"workflowBlockUuid\",null,\"queryRunOnSelectorUpdate\",false,\"runWhenPageLoadsDelay\",\"\",\"warningCodes\",[\"^;\",[]],\"data\",null,\"recordId\",\"\",\"importedQueryInputs\",[\"^3\",[]],\"_additionalScope\",[\"^;\",[]],\"isImported\",false,\"showSuccessToaster\",true,\"dataArray\",[\"^;\",[]],\"cacheKeyTtl\",\"\",\"filterBy\",\"\",\"requestSentTimestamp\",null,\"databaseHostOverride\",\"\",\"metadata\",null,\"workflowActionType\",null,\"editorMode\",\"sql\",\"queryRunTime\",null,\"actionType\",\"\",\"changesetObject\",\"\",\"shouldUseLegacySql\",false,\"errorTransformer\",\"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\"finished\",null,\"databaseNameOverride\",\"\",\"confirmationMessage\",null,\"isFetching\",false,\"changeset\",\"\",\"rawData\",null,\"queryTriggerDelay\",\"0\",\"resourceTypeOverride\",null,\"watchedParams\",[\"^;\",[]],\"enableErrorTransformer\",false,\"databaseWarehouseOverride\",\"\",\"enableBulkUpdates\",false,\"showLatestVersionUpdatedWarning\",false,\"timestamp\",0,\"evalType\",\"script\",\"importedQueryDefaults\",[\"^3\",[]],\"enableTransformer\",false,\"showUpdateSetValueDynamicallyToggle\",true,\"overrideOrgCacheForUserCache\",false,\"bulkUpdatePrimaryKey\",\"\",\"runWhenPageLoads\",false,\"transformer\",\"// Query results are available as the `data` variable\\nreturn data\",\"events\",[\"^;\",[]],\"tableName\",\"\",\"queryTimeout\",\"10000\",\"workflowId\",null,\"requireConfirmation\",false,\"queryFailureConditions\",\"\",\"changesetIsObject\",false,\"enableCaching\",false,\"allowedGroups\",[\"^;\",[]],\"databaseUsernameOverride\",\"\",\"databaseRoleOverride\",\"\",\"shouldEnableBatchQuerying\",false,\"doNotThrowOnNoOp\",false,\"offlineQueryType\",\"None\",\"queryThrottleTime\",\"750\",\"updateSetValueDynamically\",false,\"notificationDuration\",\"\"]],\"^<\",null,\"^=\",null,\"^>\",null,\"^?\",null,\"^@\",null,\"^A\",\"\",\"^B\",\"~m1720863400533\",\"^C\",\"~m1720863414443\",\"^D\",\"\",\"^E\",null]]],\"code1\",[\"^0\",[\"^ \",\"n\",\"pluginTemplate\",\"v\",[\"^ \",\"id\",\"code1\",\"^4\",null,\"^5\",\"datasource\",\"^6\",\"PythonQuery\",\"^7\",null,\"^8\",\"PythonQuery\",\"^9\",null,\"^:\",[\"^3\",[\"queryRefreshTime\",\"\",\"allowedGroupIds\",[\"^;\",[]],\"streamResponse\",false,\"lastReceivedFromResourceAt\",null,\"queryDisabledMessage\",\"\",\"servedFromCache\",false,\"offlineUserQueryInputs\",\"\",\"successMessage\",\"\",\"queryDisabled\",\"\",\"playgroundQuerySaveId\",\"latest\",\"workflowParams\",null,\"resourceNameOverride\",\"\",\"runWhenModelUpdates\",false,\"workflowRunId\",null,\"showFailureToaster\",true,\"query\",\"from datetime import datetime\\ndata_orders = query1.data\\n\\norders = []\\nfor order in data_orders:      \\n    if order['end_time'] is None:\\n      orders.append({\\n          'user_id': order['user_id'],\\n          'start_location': order['start_location'],\\n          'end_location': order['end_location'],\\n          'priority': order['priority'],\\n          'start_time': datetime.strptime(order['start_time'], \\\"%Y-%m-%d %H:%M:%S\\\"),\\n          'end_time': order['end_time']\\n      })\\n    elif order['start_time'] is None:\\n      orders.append({\\n          'user_id': order['user_id'],\\n          'start_location': order['start_location'],\\n          'end_location': order['end_location'],\\n          'priority': order['priority'],\\n          'start_time': order['start_time'],\\n          'end_time': datetime.strptime(order['end_time'], \\\"%Y-%m-%d %H:%M:%S\\\")\\n      })\\nreturn orders\",\"playgroundQueryUuid\",\"\",\"playgroundQueryId\",null,\"error\",null,\"workflowRunBodyType\",\"raw\",\"privateParams\",[\"^;\",[]],\"workflowBlockUuid\",null,\"queryRunOnSelectorUpdate\",false,\"runWhenPageLoadsDelay\",\"\",\"data\",null,\"importedQueryInputs\",[\"^3\",[]],\"isImported\",false,\"showSuccessToaster\",true,\"cacheKeyTtl\",\"\",\"requestSentTimestamp\",null,\"metadata\",null,\"workflowActionType\",null,\"queryRunTime\",null,\"changesetObject\",\"\",\"errorTransformer\",\"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\"finished\",null,\"confirmationMessage\",null,\"isFetching\",false,\"changeset\",\"\",\"rawData\",null,\"queryTriggerDelay\",\"0\",\"resourceTypeOverride\",null,\"watchedParams\",[\"^;\",[]],\"enableErrorTransformer\",false,\"showLatestVersionUpdatedWarning\",false,\"timestamp\",0,\"evalType\",\"script\",\"importedQueryDefaults\",[\"^3\",[]],\"enableTransformer\",false,\"showUpdateSetValueDynamicallyToggle\",true,\"overrideOrgCacheForUserCache\",false,\"runWhenPageLoads\",false,\"transformer\",\"// Query results are available as the `data` variable\\nreturn data\",\"events\",[\"^;\",[]],\"queryTimeout\",\"10000\",\"workflowId\",null,\"requireConfirmation\",false,\"queryFailureConditions\",\"\",\"changesetIsObject\",false,\"enableCaching\",false,\"allowedGroups\",[\"^;\",[]],\"offlineQueryType\",\"None\",\"queryThrottleTime\",\"750\",\"updateSetValueDynamically\",false,\"notificationDuration\",\"\"]],\"^<\",null,\"^=\",null,\"^>\",null,\"^?\",null,\"^@\",null,\"^A\",\"\",\"^B\",\"~m1720863422879\",\"^C\",\"~m1720863437352\",\"^D\",\"\",\"^E\",null]]],\"code2\",[\"^0\",[\"^ \",\"n\",\"pluginTemplate\",\"v\",[\"^ \",\"id\",\"code2\",\"^4\",null,\"^5\",\"datasource\",\"^6\",\"PythonQuery\",\"^7\",null,\"^8\",\"PythonQuery\",\"^9\",null,\"^:\",[\"^3\",[\"queryRefreshTime\",\"\",\"allowedGroupIds\",[\"^;\",[]],\"streamResponse\",false,\"lastReceivedFromResourceAt\",null,\"queryDisabledMessage\",\"\",\"servedFromCache\",false,\"offlineUserQueryInputs\",\"\",\"successMessage\",\"\",\"queryDisabled\",\"\",\"playgroundQuerySaveId\",\"latest\",\"workflowParams\",null,\"resourceNameOverride\",\"\",\"runWhenModelUpdates\",false,\"workflowRunId\",null,\"showFailureToaster\",true,\"query\",\"from datetime import datetime\\ndata_employees = query2.data\\nemployees = []\\nfor employee in data_employees:\\n    employees.append({\\n        'employee_name': employee['employee_name'],\\n        'max_hours': employee['max_hours'],\\n        'max_priority': employee['max_priority'],\\n        'start_time': datetime.strptime(employee['start_time'], \\\"%Y-%m-%d %H:%M:%S\\\"), \\n        'end_time': datetime.strptime(employee['end_time'], \\\"%Y-%m-%d %H:%M:%S\\\")\\n    })\\n\\nreturn employees\",\"playgroundQueryUuid\",\"\",\"playgroundQueryId\",null,\"error\",null,\"workflowRunBodyType\",\"raw\",\"privateParams\",[\"^;\",[]],\"workflowBlockUuid\",null,\"queryRunOnSelectorUpdate\",false,\"runWhenPageLoadsDelay\",\"\",\"data\",null,\"importedQueryInputs\",[\"^3\",[]],\"isImported\",false,\"showSuccessToaster\",true,\"cacheKeyTtl\",\"\",\"requestSentTimestamp\",null,\"metadata\",null,\"workflowActionType\",null,\"queryRunTime\",null,\"changesetObject\",\"\",\"errorTransformer\",\"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\"finished\",null,\"confirmationMessage\",null,\"isFetching\",false,\"changeset\",\"\",\"rawData\",null,\"queryTriggerDelay\",\"0\",\"resourceTypeOverride\",null,\"watchedParams\",[\"^;\",[]],\"enableErrorTransformer\",false,\"showLatestVersionUpdatedWarning\",false,\"timestamp\",0,\"evalType\",\"script\",\"importedQueryDefaults\",[\"^3\",[]],\"enableTransformer\",false,\"showUpdateSetValueDynamicallyToggle\",true,\"overrideOrgCacheForUserCache\",false,\"runWhenPageLoads\",false,\"transformer\",\"// Query results are available as the `data` variable\\nreturn data\",\"events\",[\"^;\",[]],\"queryTimeout\",\"10000\",\"workflowId\",null,\"requireConfirmation\",false,\"queryFailureConditions\",\"\",\"changesetIsObject\",false,\"enableCaching\",false,\"allowedGroups\",[\"^;\",[]],\"offlineQueryType\",\"None\",\"queryThrottleTime\",\"750\",\"updateSetValueDynamically\",false,\"notificationDuration\",\"\"]],\"^<\",null,\"^=\",null,\"^>\",null,\"^?\",null,\"^@\",null,\"^A\",\"\",\"^B\",\"~m1720863442933\",\"^C\",\"~m1720863455751\",\"^D\",\"\",\"^E\",null]]]]],\"^B\",null,\"version\",\"3.70.0\",\"appThemeId\",null,\"appThemeName\",null,\"appThemeModeId\",null,\"appMaxWidth\",\"100%\",\"preloadedAppJavaScript\",null,\"preloadedAppJSLinks\",[],\"testEntities\",[],\"tests\",[],\"appStyles\",\"\",\"responsiveLayoutDisabled\",false,\"loadingIndicatorsDisabled\",false,\"urlFragmentDefinitions\",[\"^;\",[]],\"pageLoadValueOverrides\",[\"^;\",[]],\"customDocumentTitle\",\"\",\"customDocumentTitleEnabled\",false,\"customShortcuts\",[],\"isGlobalWidget\",false,\"isMobileApp\",false,\"isFormApp\",false,\"shortlink\",null,\"multiScreenMobileApp\",false,\"mobileAppSettings\",[\"^ \",\"mobileOfflineModeEnabled\",false,\"mobileOfflineModeDelaySync\",false,\"mobileOfflineModeBannerMode\",\"default\",\"displaySetting\",[\"^ \",\"landscapeMode\",false,\"tabletMode\",false]],\"formAppSettings\",[\"^ \",\"customRedirectUrl\",\"\"],\"notificationsSettings\",[\"^ \",\"globalQueryShowFailureToast\",true,\"globalQueryShowSuccessToast\",false,\"globalQueryToastDuration\",4.5,\"globalToastPosition\",\"bottomRight\"],\"folders\",[\"^;\",[]],\"pageCodeFolders\",[\"^ \",\"ProcessFiles\",[],\"ImportFiles\",[]],\"queryStatusVisibility\",false,\"markdownLinkBehavior\",\"auto\",\"inAppRetoolPillAppearance\",\"NO_OVERRIDE\",\"rootScreen\",null,\"instrumentationEnabled\",false,\"experimentalFeatures\",[\"^ \",\"sourceControlTemplateDehydration\",false,\"multiplayerEditingEnabled\",false,\"disableMultiplayerEditing\",false],\"experimentalDataTabEnabled\",false,\"customComponentCollections\",[],\"savePlatform\",\"web\",\"internationalizationSettings\",[\"^ \",\"internationalizationEnabled\",false,\"internationalizationFiles\",[]],\"appTesting\",null]]]","triggerWebhooks":[{"name":"startTrigger","uuid":"startTrigger","inputSchema":{"properties":[]},"useHeaderApiKey":false,"exampleInputJSON":"{\n  \"date\": \"2024-08-01\"\n}"}],"customLibraries":[{"version":"3.5.0.0","language":"python","codeString":"","libraryName":"typing"},{"version":"5.5","language":"python","codeString":"","libraryName":"DateTime"},{"version":"4.10.0","language":"python","codeString":"","libraryName":"googlemaps"},{"version":"3.9.0","language":"python","codeString":"","libraryName":"matplotlib"},{"version":"4.17.21","language":"javascript","variable":"_","codeString":"/* Edit library variable below */\n\nconst _ = require('lodash')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n","libraryName":"lodash"},{"version":"2.1.0","language":"javascript","variable":"numbro","codeString":"/* Edit library variable below */\n\nconst numbro = require('numbro')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n","libraryName":"numbro"},{"version":"5.3.2","language":"javascript","variable":"Papa","codeString":"/* Edit library variable below */\n\nconst Papa = require('papaparse')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n","libraryName":"papaparse"},{"version":"0.5.23","language":"javascript","variable":"moment","codeString":"/* Edit library variable below */\n\nconst moment = require('moment-timezone')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n","libraryName":"moment-timezone"},{"version":"3.4.0","language":"javascript","variable":"uuid","codeString":"/* Edit library variable below */\n\nconst uuid = require('uuid')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n","libraryName":"uuid"}],"createdBy":1199477,"protected":false,"pythonLanguageConfigurationId":"751dee28-1ce0-4e69-9fe8-86b89e0e391f","javascriptLanguageConfigurationSaveId":null,"pythonLanguageConfigurationSaveId":"13a3942f-e1ec-497a-8417-307770a32c62","setupScripts":{"python":{"codeString":""},"javascript":{"codeString":"// lodash\n/* Edit library variable below */\n\nconst _ = require('lodash')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n\n// numbro\n/* Edit library variable below */\n\nconst numbro = require('numbro')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n\n// papaparse\n/* Edit library variable below */\n\nconst Papa = require('papaparse')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n\n// moment-timezone\n/* Edit library variable below */\n\nconst moment = require('moment-timezone')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n\n// uuid\n/* Edit library variable below */\n\nconst uuid = require('uuid')\n\n/* Add destructured imports from library below\neg. const { pow, log } = require(\"mathjs\") */\n"}}}